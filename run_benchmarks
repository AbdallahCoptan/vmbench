#!/usr/bin/env python3


import argparse
import json
import os
import os.path
import socket
import subprocess
import sys
import textwrap
import time


_dir = os.path.dirname(__file__)

_cache = os.path.abspath(os.path.join(_dir, '.cache'))
_socket = os.path.abspath(os.path.join(_dir, 'sockets'))

server_base = ['docker', 'run', '--rm', '-t', '-p', '25000:25000',
               '-e', 'UID={}'.format(os.geteuid()),
               '-e', 'GID={}'.format(os.getegid()),
               '-v', '{_cache}:/var/lib/cache'.format(_cache=_cache),
               '-v', '{_socket}:/tmp/sockets'.format(_socket=_socket),
               '--name', 'magicbench', 'magic/benchmark']

python = ['vex', 'bench', 'python']
nodejs = ['nodejs']

echo_client = ['./echo_client', '--output-format=json']

tcp_address = '127.0.0.1:25000'
unix_address = 'file:{_socket}/server.sock'.format(_socket=_socket)

tcp_client = echo_client + ['--addr={}'.format(tcp_address)]
unix_client = echo_client + ['--addr={}'.format(unix_address)]

http_client = "wrk --latency -d 30 -c 200 -t 4 http://127.0.0.1:25000/{msize}"

benchmarks = [{
    'name': 'tcpecho-gevent',
    'title': 'TCP echo server (gevent)',
    'server': python + ['/usr/src/servers/gevecho.py'],
    'server_address': tcp_address,
    'client': tcp_client,
}, {
    'name': 'tcpecho-tornado',
    'title': 'TCP echo server (tornado)',
    'server': python + ['/usr/src/servers/torecho.py'],
    'server_address': tcp_address,
    'client': tcp_client,
}, {
    'name': 'tcpecho-twisted',
    'title': 'TCP echo server (twisted)',
    'server': python + ['/usr/src/servers/twistedecho.py'],
    'server_address': tcp_address,
    'client': tcp_client,
}, {
    'name': 'tcpecho-curio-socket',
    'title': 'TCP echo server (curio/socket)',
    'server': python + ['/usr/src/servers/curioecho.py'],
    'server_address': tcp_address,
    'client': tcp_client,
}, {
    'name': 'tcpecho-curio-streams',
    'title': 'TCP echo server (curio/streams)',
    'server': python + ['/usr/src/servers/curioecho_streams.py'],
    'server_address': tcp_address,
    'client': tcp_client,
}, {
    'name': 'tcpecho-nodejs',
    'title': 'TCP echo server (nodejs)',
    'server': nodejs + ['/usr/src/servers/nodeecho.js'],
    'server_address': tcp_address,
    'client': tcp_client,
}, {
    'name': 'tcpecho-asyncio-streams',
    'title': 'TCP echo server (asyncio/streams)',
    'server': python + ['/usr/src/servers/asyncioecho.py',
                        '--addr=0.0.0.0:25000',
                        '--streams'],
    'server_address': tcp_address,
    'client': tcp_client,
}, {
    'name': 'tcpecho-asyncio-proto',
    'title': 'TCP echo server (asyncio/proto)',
    'server': python + ['/usr/src/servers/asyncioecho.py',
                        '--addr=0.0.0.0:25000',
                        '--proto'],
    'server_address': tcp_address,
    'client': tcp_client,
}, {
    'name': 'unixecho-asyncio-streams',
    'title': 'Unix socket echo server (asyncio/streams)',
    'server': python + ['/usr/src/servers/asyncioecho.py',
                        '--addr=file:/tmp/sockets/server.sock',
                        '--streams'],
    'server_address': unix_address,
    'client': unix_client,
}, {
    'name': 'unixecho-asyncio-proto',
    'title': 'Unix socket echo server (asyncio/proto)',
    'server': python + ['/usr/src/servers/asyncioecho.py',
                        '--addr=file:/tmp/sockets/server.sock',
                        '--proto'],
    'server_address': unix_address,
    'client': unix_client,
}, {
    'name': 'tcpecho-uvloop-streams',
    'title': 'TCP echo server (uvloop/streams)',
    'server': python + ['/usr/src/servers/asyncioecho.py',
                        '--addr=0.0.0.0:25000',
                        '--streams', '--uvloop'],
    'server_address': tcp_address,
    'client': tcp_client,
}, {
    'name': 'tcpecho-uvloop-proto',
    'title': 'TCP echo server (uvloop/proto)',
    'server': python + ['/usr/src/servers/asyncioecho.py',
                        '--addr=0.0.0.0:25000',
                        '--proto', '--uvloop'],
    'server_address': tcp_address,
    'client': tcp_client,
}, {
    'name': 'unixecho-uvloop-streams',
    'title': 'Unix socket echo server (uvloop/streams)',
    'server': python + ['/usr/src/servers/asyncioecho.py',
                        '--addr=file:/tmp/sockets/server.sock',
                        '--streams', '--uvloop'],
    'server_address': unix_address,
    'client': unix_client,
}, {
    'name': 'unixecho-uvloop-proto',
    'title': 'Unix socket echo server (uvloop/proto)',
    'server': python + ['/usr/src/servers/asyncioecho.py',
                        '--addr=file:/tmp/sockets/server.sock',
                        '--proto', '--uvloop'],
    'server_address': unix_address,
    'client': unix_client,
}]


def abort(msg):
    print(msg, file=sys.stdout)
    sys.exit(1)


def start_and_wait_for_server(server_cmd, address, timeout=60):
    kill_server()

    server = subprocess.Popen(server_cmd, universal_newlines=True,
                              stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    start = time.monotonic()

    if address.startswith('file:'):
        family = socket.AF_UNIX
        addr = address[5:]
    else:
        family = socket.AF_INET
        addr = address.split(':')
        addr[1] = int(addr[1])
        addr = tuple(addr)

    print('Trying to connect to server at address {}'.format(address))

    while time.monotonic() - start < timeout:
        sock = socket.socket(family, socket.SOCK_STREAM)
        sock.settimeout(time.monotonic() - start)
        try:
            sock.connect(addr)
            sock.sendall(b'ping')
            if sock.recv(4):
                print('Server is up and running.')
            else:
                raise IOError('socket read')
        except IOError:
            if server.returncode is not None:
                abort('Could not start server\n' +
                      '----------------------\n' +
                      '\n\n'.join(server.communicate()))
        else:
            sock.close()
            return server

    kill_server()

    abort('Could not start server\n' +
          '----------------------\n' +
          '\n\n'.join(server.communicate()))


def server_is_running():
    try:
        ret = subprocess.check_output(
                ['docker', 'inspect', '--type=container',
                 '--format="{{ .State.Running }}"', 'magicbench'],
                stderr=subprocess.DEVNULL,
                universal_newlines=True)

    except subprocess.CalledProcessError:
        return False

    else:
        return ret == 'true\n'


def server_container_exists():
    ret = subprocess.call(['docker', 'inspect', '--type=container',
                           'magicbench'],
                           stdout=subprocess.DEVNULL,
                           stderr=subprocess.DEVNULL)
    return ret == 0


def kill_server():
    if server_is_running():
        print('Shutting down server...')
        subprocess.check_output(['docker', 'stop', 'magicbench'])

    if server_container_exists():
        print('Removing server container...')
        subprocess.check_output(['docker', 'rm', 'magicbench'])


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--duration', '-D', default=30, type=int,
                        help='duration of each benchmark in seconds')
    parser.add_argument('--benchmarks', type=str,
                        help='comma-separated list of benchmarks to run')
    parser.add_argument('--concurrency-levels', type=int, default=[10],
                        nargs='+',
                        help='a list of concurrency levels to use')
    parser.add_argument('--payload-size-levels', type=int, nargs='+',
                        default=[1024, 10240, 102400],
                        help='comma-separated list of message size levels ' +
                             'to use (in bytes)')
    parser.add_argument('--save-json', '-J', type=str,
                        help='path to save benchmark results in JSON format')
    args = parser.parse_args()

    if not os.path.exists(_socket):
        os.mkdir(_socket)

    if args.benchmarks:
        benchmarks_to_run = args.benchmarks.split(',')
    else:
        benchmarks_to_run = {b['name'] for b in benchmarks}

    benchmarks_data = []

    variations = []

    for concurrency in sorted(args.concurrency_levels):
        for msgsize in sorted(args.payload_size_levels):
            variations.append({
                'title': '{}kb messages, concurrency {}'.format(
                    round(msgsize / 1024, 1), concurrency
                ),
                'args': [
                    '--msize={}'.format(msgsize),
                    '--concurrency={}'.format(concurrency)
                ]
            })

    warmup_concurrency = max(args.concurrency_levels)
    warmup = ['--msize=1024', '--duration=5',
              '--concurrency={}'.format(warmup_concurrency)]

    for benchmark in benchmarks:
        if benchmark['name'] not in benchmarks_to_run:
            continue

        print(benchmark['title'])
        print('=' * len(benchmark['title']))
        print()

        print('Starting server...')
        server_cmd = server_base + benchmark['server']
        print('  ' + ' '.join(server_cmd))
        start_and_wait_for_server(server_cmd, benchmark['server_address'])
        print()

        print('Warming up server...')
        warmup_cmd = benchmark['client'] + warmup
        print(' '.join(warmup_cmd))
        subprocess.check_output(warmup_cmd)
        print()

        duration = args.duration

        benchmark_data = {
            'name': benchmark['name'],
            'variations': []
        }

        benchmarks_data.append(benchmark_data)

        try:
            for variation in variations:
                title = 'BENCHMARK: {}'.format(variation['title'])
                print(title)
                print('-' * len(title))
                client_cmd = benchmark['client'] + variation['args']
                client_cmd += ['--duration={}'.format(duration)]
                print(' '.join(client_cmd))
                output = subprocess.check_output(
                            client_cmd, universal_newlines=True)
                data = json.loads(output)

                format_data = data.copy()

                format_data['latency_percentiles'] = '; '.join(
                    '{}% under {}ms'.format(*v)
                    for v in data['latency_percentiles'])

                output = textwrap.dedent('''\
                {messages} messages in {duration} seconds
                Latency: min {latency_min}ms; max {latency_max}ms; mean {latency_mean}ms; std {latency_std}ms ({latency_cv}%);
                Latency distribtion: {latency_percentiles}
                Requests/sec: {rps}
                Transfer/sec: {transfer}MiB
                ''').format(duration=duration, **format_data)

                print(output)

                benchmark_data['variations'].append(data)
        finally:
            kill_server()

        print()

    if args.save_json:
        with open(args.save_json, 'w') as f:
            json.dump(benchmarks_data, f)


if __name__ == '__main__':
    main()
